let nextMove hand dict board =
	if hand isEmpty then SMPass // hvis vi ikke modtager flere bogstaver fra server
	else
		if board.isEmpty then // hvis spillet lige er startet
			board.center = maxWordFinder hand dict board // placer ordet i centrum af board
	    else
        

// metode til at returnere gyldigt ord med maximal score 		 
let maxWordFinder hand dict board: string option =
    let rec letterCombinator hand dict word: string option // word er kombinationen af bokstaver som du har indtil videre
        match hand with
        | [] -> 
            if dict.lookup word then
                return word
            else
                return None
        | x:xs ->
            let word1 = letterCombinator xs (word + x)
            let word2 = letterCombinator xs (word)
                if word1 = None and word2 = None then
                    return None
                else
                    if word1 > word2 then
                        return Some word1
                    else
                        return Some word2
            

		  


TrieNode:
    - children: dictionary of character to TrieNode
    - isWord: boolean

Trie:
    - root: TrieNode
    
    methods:
        - insert(word: string)
            - insert a word into the trie
        
        - search(word: string) -> boolean
            - returns true if the word exists in the trie, false otherwise
        
        - startsWith(prefix: string) -> boolean
            - returns true if there is any word in the trie that starts with the given prefix, false otherwise

        - getNode(prefix: string) -> TrieNode
            - returns the TrieNode representing the end of the prefix, or null if the prefix is not found



### Pseudocode for Backtracking


backtrack(board, node, row, col, visited, currentWord, result, trie):
    - if node.isWord:
        - add currentWord to result
        - set node.isWord = false  // prevent duplicates

    - for each direction (up, down, left, right):
        - nextRow, nextCol = calculate next position based on direction
        - if nextRow, nextCol is within bounds of board AND not visited[nextRow, nextCol]:
            - nextChar = board[nextRow, nextCol]
            - nextNode = node.children.get(nextChar)
            - if nextNode exists:
                - mark nextRow, nextCol as visited
                - add nextChar to currentWord
                - recursively call backtrack with updated arguments
                - remove nextChar from currentWord
                - unmark nextRow, nextCol as visited

findWords(board, words):
    - trie = buildTrie(words)
    - result = set()
    - visited = 2D array of false of same size as board
    - for each cell in board:
        - char = board[row, col]
        - node = trie.getNode(char)
        - if node exists:
            - call backtrack with initial arguments
    - return result

buildTrie(words):
    - trie = Trie()
    - for each word in words:
        - trie.insert(word)
    - return trie







    Generate Possible Words:

- We start with an empty prefix and our hand of letters: ['a'; 'e'; 't'; 'r'; 'i'; 's'; 'n'].

- We recursively explore all possible combinations of letters from the hand, checking if each combination forms a valid word in the dictionary.

- For example, we might explore combinations like "a", "e", "t", "r", "i", "s", "n", "ae", "at", "ar", "an", "et", etc.
Calculate Scores:

- For each valid word found, we calculate its score based on the given scoring system.

- For example, the word "ae" might have a score of 2 (assuming 'a' = 1 and 'e' = 1), the word "at" might have a score of 2, etc.

    Find Maximum Score:

- We keep track of the word with the maximum score encountered so far as we explore all possible combinations.

- Once we have explored all combinations, we return the word with the maximum score as our result.